Transaction
트랜잭션이 다른 트랜잭션에게 어떻게 영향을 미치는 지를 정의
정의 : ISOLATION LEVEL (고립화 레벨)

.oracle DMBS는 읽이 일관성을 위해 db블록을 멀티 버전으로 관리
.DMBS마다 읽기 일관성 레벨이 다름


- lv 0~3 총 4단계
트린젝션 레벨 변경 명령어
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;


LV0 Read Uncommitted
오라클 미지원
가장 낮은 레벨
선행 트랜잭션의 커밋 되지 않은 데이터를 후행 트랜잭션 에서 볼 수있는 설정
(커밋 되지 않은 커리문의 결과를 다른 DB에서 확인할수 있음)


lv1 Read Commited
대부분의 DBMS의 기본설정
커밋되지 않은 데이터는 후행 트랜잭션에서 볼 수 없다
(커밋 되지 않은 커리문의 결과를 다른 DB에서 확인할수 없음)


lv2 Repaeatable Read
선행 트랜잭션이 읽은 데이터를 후행 트랜젝션에서 데이터를 *수정, 삭제 하지 못함* 	(쿼리문 실행= 트랜잭션 , commit= 트랜잭션 확정)
	-> 선행 트랜잭션에서 같은 조회쿼리를 실행시 결과가 같음
	-> 하지만 후행 트랜잭션에서 	*신규 입력은 가능*
		Phantom Read : 없던 데이터가 새로 조회는 현상
	-> 오라클에서 공식지원하지 않음
		for update절을 이용해 효과를 낼 수 있음
		[SELECT *
		   FROM dept
		  WHERE dept_no =''
		    FOR UPDATE;]
(실행한만 하고 커밋하지 않은 쿼리문이 있다면, 다른 DB에서 그 정보에 대해 수정(UPDATE)이나 삭제(DELETE)가 불가능하지만 신규입력(INSERT)은 가능하다)


lv3 Serializable
모든 작업을 하나의 트랜젝션에서 처리하는 것과 같은 높은 고립수준을 제공한다. 고립수준이 높은 만큼, 동시성 처리효율은 떨어집니다.
격리수준이 SERIALIZABLE일 경우 읽기 작업에도 공유 잠금을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다.
이러한 특성 때문에 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생하게 된다.
(다른 트랜잭션이 커밋하기 전의 데이터만 보인다)



-읽기 일관성
ORACLE 은 locking 메카니즘이다른 DBMS와 차이가 있음
일관성 레벨을 올려도 타 DBMS만큼 동시성이 저하되지 않음 (멀티 버전 데이터 블럭)
메커니즘 차이로 다른 DBMS에는 없는 에러가 있음 snapshot too old (snapshot=블록의버전)









트랜젝션 시작 : 월별 부문, 본부, 팀 파트별 식적 요약 레포트
---------------------------------------------------

---1부문(300) - 1본부(100), 2본부(200)
---월별 부문에 대한 요약
select 월, 부문코드 SUM(판매금액)
FROM 실적
WHERE 월 ='202011'
  AND 조직코드 IN( SELECT 조직코드
  				  FROM 조직
  				 WHERE 부문코드='영업1부문')
GROUP BY 월, 부문코드;



---영업 1	부문에는 영업 1본부, 2본부가 존재
select 월, 본부코드 SUM(판매금액)
FROM 실적
WHERE 월 ='202011'
  AND 조직코드 IN( SELECT 조직코드
  				  FROM 조직
  				 WHERE 부문코드='영업1부문')
GROUP BY 월, 조직코드);










